
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>正则表达式 | 陈小达的个人博客</title>
    <meta name="author" content="chenjunda" />
    <meta name="description" content="学习笔记" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>陈小达的个人博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;陈小达的个人博客</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>正则表达式</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/6/28
        </span>
        
        <span class="category">
            <a href="/categories/java/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                java
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/javaSE/" style="color: #00bcd4">
                    javaSE
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="1-1-正则表达式的概念及演示"><a href="#1-1-正则表达式的概念及演示" class="headerlink" title="1.1 正则表达式的概念及演示"></a>1.1 正则表达式的概念及演示</h2><ul>
<li><p>在Java中，我们经常需要验证一些字符串，例如：年龄必须是2位的数字、用户名必须是8位长度而且只能包含大小写字母、数字等。正则表达式就是用来验证各种字符串的规则。它内部描述了一些规则，我们可以验证用户输入的字符串是否匹配这个规则。</p>
<span id="more"></span>
</li>
<li><p>先看一个不使用正则表达式验证的例子：下面的程序让用户输入一个QQ号码，我们要验证：</p>
<ul>
<li>QQ号码必须是5–15位长度</li>
<li>而且必须全部是数字</li>
<li>而且首位不能为0</li>
</ul>
</li>
</ul>
<pre><code class="java">package com.itheima.a08regexdemo;

public class RegexDemo1 &#123;
    public static void main(String[] args) &#123;
        /* 假如现在要求校验一个qq号码是否正确。
            规则:6位及20位之内，日不能在开头，必须全部是数字。
            先使用目前所学知识完成校验需求然后体验一下正则表达式检验。
        */

        String qq =&quot;1234567890&quot;;
        System.out.println(checkQQ(qq));

        System.out.println(qq.matches(&quot;[1-9]\\d&#123;5,19&#125;&quot;));

    &#125;

    public static boolean checkQQ(String qq) &#123;
        //规则:6位及20位之内，日不能在开头，必须全部是数字 。
        //核心思想:
        //先把异常数据进行过滤
        //下面的就是满足要求的数据了。
        int len = qq.length();
        if (len &lt; 6 || len &gt; 20) &#123;
            return false;
        &#125;
        //0不能在开头
        if (qq.startsWith(&quot;0&quot;)) &#123;
            return false;
        &#125;
        //必须全部是数字
        for (int i = 0; i &lt; qq.length(); i++) &#123;
            char c = qq.charAt(i);
            if (c &lt; &#39;0&#39; | c &gt; &#39;9&#39;) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<ul>
<li>使用正则表达式验证：</li>
</ul>
<pre><code class="java">public class Demo &#123;
    public static void main(String[] args) &#123;
        String qq =&quot;1234567890&quot;;
        System.out.println(qq.matches(&quot;[1-9]\\d&#123;5,19&#125;&quot;));
    &#125;
&#125;
</code></pre>
<p><strong>我们接下来就重点学习怎样写正则表达式</strong></p>
<h2 id="1-2-正则表达式-字符类"><a href="#1-2-正则表达式-字符类" class="headerlink" title="1.2 正则表达式-字符类"></a>1.2 正则表达式-字符类</h2><ul>
<li>语法示例：</li>
</ul>
<ol>
<li>[abc]：代表a或者b，或者c字符中的一个。</li>
<li>[^abc]：代表除a,b,c以外的任何字符。</li>
<li>[a-z]：代表a-z的所有小写字符中的一个。</li>
<li>[A-Z]：代表A-Z的所有大写字符中的一个。</li>
<li>[0-9]：代表0-9之间的某一个数字字符。</li>
<li>[a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。</li>
<li>[a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。</li>
</ol>
<ul>
<li>代码示例：</li>
</ul>
<pre><code class="java">package com.itheima.a08regexdemo;

public class RegexDemo2 &#123;
    public static void main(String[] args) &#123;
        //public boolean matches(String regex):判断是否与正则表达式匹配，匹配返回true
        // 只能是a b c
        System.out.println(&quot;-----------1-------------&quot;);
        System.out.println(&quot;a&quot;.matches(&quot;[abc]&quot;)); // true
        System.out.println(&quot;z&quot;.matches(&quot;[abc]&quot;)); // false

        // 不能出现a b c
        System.out.println(&quot;-----------2-------------&quot;);
        System.out.println(&quot;a&quot;.matches(&quot;[^abc]&quot;)); // false
        System.out.println(&quot;z&quot;.matches(&quot;[^abc]&quot;)); // true
        System.out.println(&quot;zz&quot;.matches(&quot;[^abc]&quot;)); //false
        System.out.println(&quot;zz&quot;.matches(&quot;[^abc][^abc]&quot;)); //true

        // a到zA到Z(包括头尾的范围)
        System.out.println(&quot;-----------3-------------&quot;);
        System.out.println(&quot;a&quot;.matches(&quot;[a-zA-z]&quot;)); // true
        System.out.println(&quot;z&quot;.matches(&quot;[a-zA-z]&quot;)); // true
        System.out.println(&quot;aa&quot;.matches(&quot;[a-zA-z]&quot;));//false
        System.out.println(&quot;zz&quot;.matches(&quot;[a-zA-Z]&quot;)); //false
        System.out.println(&quot;zz&quot;.matches(&quot;[a-zA-Z][a-zA-Z]&quot;)); //true
        System.out.println(&quot;0&quot;.matches(&quot;[a-zA-Z]&quot;));//false
        System.out.println(&quot;0&quot;.matches(&quot;[a-zA-Z0-9]&quot;));//true


        // [a-d[m-p]] a到d，或m到p
        System.out.println(&quot;-----------4-------------&quot;);
        System.out.println(&quot;a&quot;.matches(&quot;[a-d[m-p]]&quot;));//true
        System.out.println(&quot;d&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true
        System.out.println(&quot;m&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true
        System.out.println(&quot;p&quot;.matches(&quot;[a-d[m-p]]&quot;)); //true
        System.out.println(&quot;e&quot;.matches(&quot;[a-d[m-p]]&quot;)); //false
        System.out.println(&quot;0&quot;.matches(&quot;[a-d[m-p]]&quot;)); //false

        // [a-z&amp;&amp;[def]] a-z和def的交集。为:d，e，f
        System.out.println(&quot;----------5------------&quot;);
        System.out.println(&quot;a&quot;.matches(&quot;[a-z&amp;[def]]&quot;)); //false
        System.out.println(&quot;d&quot;.matches(&quot;[a-z&amp;&amp;[def]]&quot;)); //true
        System.out.println(&quot;0&quot;.matches(&quot;[a-z&amp;&amp;[def]]&quot;)); //false

        // [a-z&amp;&amp;[^bc]] a-z和非bc的交集。(等同于[ad-z])
        System.out.println(&quot;-----------6------------_&quot;);
        System.out.println(&quot;a&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;));//true
        System.out.println(&quot;b&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;)); //false
        System.out.println(&quot;0&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;)); //false

        // [a-z&amp;&amp;[^m-p]] a到z和除了m到p的交集。(等同于[a-1q-z])
        System.out.println(&quot;-----------7-------------&quot;);
        System.out.println(&quot;a&quot;.matches(&quot;[a-z&amp;&amp;[^m-p]]&quot;)); //true
        System.out.println(&quot;m&quot;.matches(&quot;[a-z&amp;&amp;[^m-p]]&quot;)); //false
        System.out.println(&quot;0&quot;.matches(&quot;[a-z&amp;&amp;[^m-p]]&quot;)); //false

    &#125;
&#125;
</code></pre>
<h2 id="1-3-正则表达式-逻辑运算符"><a href="#1-3-正则表达式-逻辑运算符" class="headerlink" title="1.3 正则表达式-逻辑运算符"></a>1.3 正则表达式-逻辑运算符</h2><ul>
<li>语法示例：<ol>
<li>&amp;&amp;：并且</li>
<li>|    ：或者</li>
<li>\  ：转义字符</li>
</ol>
</li>
<li>代码示例：</li>
</ul>
<pre><code class="java">public class Demo &#123;
    public static void main(String[] args) &#123;
        String str = &quot;had&quot;;
        
        //1.要求字符串是小写辅音字符开头，后跟ad
        String regex = &quot;[a-z&amp;&amp;[^aeiou]]ad&quot;;
        System.out.println(&quot;1.&quot; + str.matches(regex));
        
        //2.要求字符串是aeiou中的某个字符开头，后跟ad
        regex = &quot;[a|e|i|o|u]ad&quot;;//这种写法相当于：regex = &quot;[aeiou]ad&quot;;
        System.out.println(&quot;2.&quot; + str.matches(regex));
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.a08regexdemo;

public class RegexDemo3 &#123;
    public static void main(String[] args) &#123;
        // \ 转义字符 改变后面那个字符原本的含义
        //练习:以字符串的形式打印一个双引号
        //&quot;在Java中表示字符串的开头或者结尾

        //此时\表示转义字符，改变了后面那个双引号原本的含义
        //把他变成了一个普普通通的双引号而已。
        System.out.println(&quot;\&quot;&quot;);

        // \表示转义字符
        //两个\的理解方式：前面的\是一个转义字符，改变了后面\原本的含义，把他变成一个普普通通的\而已。
        System.out.println(&quot;c:Users\\moon\\IdeaProjects\\basic-code\\myapi\\src\\com\\itheima\\a08regexdemo\\RegexDemo1.java&quot;);




    &#125;
&#125;
</code></pre>
<h2 id="1-4-正则表达式-预定义字符"><a href="#1-4-正则表达式-预定义字符" class="headerlink" title="1.4 正则表达式-预定义字符"></a>1.4 正则表达式-预定义字符</h2><ul>
<li>语法示例：<ol>
<li>“.” ： 匹配任何字符。</li>
<li>“\d”：任何数字[0-9]的简写；</li>
<li>“\D”：任何非数字[^0-9]的简写；</li>
<li>“\s”： 空白字符：[ \t\n\x0B\f\r] 的简写</li>
<li>“\S”： 非空白字符：[^\s] 的简写</li>
<li>“\w”：单词字符：[a-zA-Z_0-9]的简写</li>
<li>“\W”：非单词字符：[^\w]</li>
</ol>
</li>
<li>代码示例：</li>
</ul>
<pre><code class="java">public class Demo &#123;
    public static void main(String[] args) &#123;
        //.表示任意一个字符
        System.out.println(&quot;你&quot;.matches(&quot;..&quot;)); //false
        System.out.println(&quot;你&quot;.matches(&quot;.&quot;)); //true
        System.out.println(&quot;你a&quot;.matches(&quot;..&quot;));//true

        // \\d 表示任意的一个数字
        // \\d只能是任意的一位数字
        // 简单来记:两个\表示一个\
        System.out.println(&quot;a&quot;.matches(&quot;\\d&quot;)); // false
        System.out.println(&quot;3&quot;.matches(&quot;\\d&quot;)); // true
        System.out.println(&quot;333&quot;.matches(&quot;\\d&quot;)); // false

        //\\w只能是一位单词字符[a-zA-Z_0-9]
        System.out.println(&quot;z&quot;.matches(&quot;\\w&quot;)); // true
        System.out.println(&quot;2&quot;.matches(&quot;\\w&quot;)); // true
        System.out.println(&quot;21&quot;.matches(&quot;\\w&quot;)); // false
        System.out.println(&quot;你&quot;.matches(&quot;\\w&quot;));//false

        // 非单词字符
        System.out.println(&quot;你&quot;.matches(&quot;\\W&quot;)); // true
        System.out.println(&quot;---------------------------------------------&quot;);
        // 以上正则匹配只能校验单个字符。


        // 必须是数字 字母 下划线 至少 6位
        System.out.println(&quot;2442fsfsf&quot;.matches(&quot;\\w&#123;6,&#125;&quot;));//true
        System.out.println(&quot;244f&quot;.matches(&quot;\\w&#123;6,&#125;&quot;));//false

        // 必须是数字和字符 必须是4位
        System.out.println(&quot;23dF&quot;.matches(&quot;[a-zA-Z0-9]&#123;4&#125;&quot;));//true
        System.out.println(&quot;23 F&quot;.matches(&quot;[a-zA-Z0-9]&#123;4&#125;&quot;));//false
        System.out.println(&quot;23dF&quot;.matches(&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;));//true
        System.out.println(&quot;23_F&quot;.matches(&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;));//false
        
    &#125;
&#125;
</code></pre>
<h2 id="1-5-正则表达式-数量词"><a href="#1-5-正则表达式-数量词" class="headerlink" title="1.5 正则表达式-数量词"></a>1.5 正则表达式-数量词</h2><ul>
<li>语法示例：<ol>
<li>X? : 0次或1次</li>
<li>X* : 0次到多次</li>
<li>X+ : 1次或多次</li>
<li>X{n} : 恰好n次</li>
<li>X{n,} : 至少n次</li>
<li>X{n,m}: n到m次(n和m都是包含的)</li>
</ol>
</li>
<li>代码示例：</li>
</ul>
<pre><code class="java">public class Demo &#123;
    public static void main(String[] args) &#123;
         // 必须是数字 字母 下划线 至少 6位
        System.out.println(&quot;2442fsfsf&quot;.matches(&quot;\\w&#123;6,&#125;&quot;));//true
        System.out.println(&quot;244f&quot;.matches(&quot;\\w&#123;6,&#125;&quot;));//false

        // 必须是数字和字符 必须是4位
        System.out.println(&quot;23dF&quot;.matches(&quot;[a-zA-Z0-9]&#123;4&#125;&quot;));//true
        System.out.println(&quot;23 F&quot;.matches(&quot;[a-zA-Z0-9]&#123;4&#125;&quot;));//false
        System.out.println(&quot;23dF&quot;.matches(&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;));//true
        System.out.println(&quot;23_F&quot;.matches(&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;));//false
    &#125;
&#125;
</code></pre>
<h2 id="1-6-正则表达式练习1"><a href="#1-6-正则表达式练习1" class="headerlink" title="1.6 正则表达式练习1"></a>1.6 正则表达式练习1</h2><p>需求：</p>
<p>​	请编写正则表达式验证用户输入的手机号码是否满足要求。</p>
<p>​	请编写正则表达式验证用户输入的邮箱号是否满足要求。</p>
<p>​	请编写正则表达式验证用户输入的电话号码是否满足要求。</p>
<p>​	验证手机号码 13112345678 13712345667 13945679027 139456790271</p>
<p>​	验证座机电话号码 020-2324242 02122442 027-42424 0712-3242434</p>
<p>​	验证邮箱号码 <a href="mailto:&#x33;&#50;&#x33;&#50;&#x33;&#x32;&#x33;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;">&#x33;&#50;&#x33;&#50;&#x33;&#x32;&#x33;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;</a> <a href="mailto:&#122;&#x68;&#97;&#110;&#x67;&#x73;&#97;&#x6e;&#64;&#105;&#x74;&#x63;&#97;&#x73;&#116;&#46;&#x63;&#x6e;&#x6e;">&#122;&#x68;&#97;&#110;&#x67;&#x73;&#97;&#x6e;&#64;&#105;&#x74;&#x63;&#97;&#x73;&#116;&#46;&#x63;&#x6e;&#x6e;</a> <a href="mailto:&#100;&#x6c;&#x65;&#105;&#x30;&#x30;&#x30;&#57;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;">&#100;&#x6c;&#x65;&#105;&#x30;&#x30;&#x30;&#57;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;</a> <a href="mailto:&#x64;&#108;&#101;&#x69;&#48;&#x30;&#48;&#x39;&#x40;&#x70;&#x63;&#105;&#46;&#x63;&#111;&#109;&#46;&#99;&#x6e;">&#x64;&#108;&#101;&#x69;&#48;&#x30;&#48;&#x39;&#x40;&#x70;&#x63;&#105;&#46;&#x63;&#111;&#109;&#46;&#99;&#x6e;</a></p>
<p>代码示例：</p>
<pre><code class="java">package com.itheima.a08regexdemo;

public class RegexDemo4 &#123;
    public static void main(String[] args) &#123;
        /*
            需求
            请编写正则表达式验证用户输入的手机号码是否满足要求。请编写正则表达式验证用户输入的邮箱号是否满足要求。请编写正则表达式验证用户输入的电话号码是否满足要求。
            验证手机号码 13112345678 13712345667 13945679027 139456790271
            验证座机电话号码 020-2324242 02122442 027-42424 0712-3242434
            验证邮箱号码 3232323@qq.com zhangsan@itcast.cnn dlei0009@163.com dlei0009@pci.com.cn
        */

        //心得:
        //拿着一个正确的数据，从左到右依次去写。
        //13112345678
        //分成三部分:
        //第一部分:1 表示手机号码只能以1开头
        //第二部分:[3-9] 表示手机号码第二位只能是3-9之间的
        //第三部分:\\d&#123;9&#125; 表示任意数字可以出现9次，也只能出现9次
        String regex1 = &quot;1[3-9]\\d&#123;9&#125;&quot;;
        System.out.println(&quot;13112345678&quot;.matches(regex1));//true
        System.out.println(&quot;13712345667&quot;.matches(regex1));//true
        System.out.println(&quot;13945679027&quot;.matches(regex1));//true
        System.out.println(&quot;139456790271&quot;.matches(regex1));//false
        System.out.println(&quot;-----------------------------------&quot;);

        //座机电话号码
        //020-2324242 02122442 027-42424 0712-3242434
        //思路:
        //在书写座机号正则的时候需要把正确的数据分为三部分
        //一:区号@\\d&#123;2,3&#125;
        //      0:表示区号一定是以0开头的
        //      \\d&#123;2,3&#125;:表示区号从第二位开始可以是任意的数字，可以出现2到3次。
        //二:- ?表示次数，日次或一次
        //三:号码 号码的第一位也不能以日开头，从第二位开始可以是任意的数字，号码的总长度:5-10位
        String regex2 = &quot;0\\d&#123;2,3&#125;-?[1-9]\\d&#123;4,9&#125;&quot;;
        System.out.println(&quot;020-2324242&quot;.matches(regex2));
        System.out.println(&quot;02122442&quot;.matches(regex2));
        System.out.println(&quot;027-42424&quot;.matches(regex2));
        System.out.println(&quot;0712-3242434&quot;.matches(regex2));

        //邮箱号码
        //3232323@qq.com zhangsan@itcast.cnn dlei0009@163.com dlei0009@pci.com.cn
        //思路:
        //在书写邮箱号码正则的时候需要把正确的数据分为三部分
        //第一部分:@的左边 \\w+
        //      任意的字母数字下划线，至少出现一次就可以了
        //第二部分:@ 只能出现一次
        //第三部分:
        //      3.1         .的左边[\\w&amp;&amp;[^_]]&#123;2,6&#125;
        //                  任意的字母加数字，总共出现2-6次(此时不能出现下划线)
        //      3.2         . \\.
        //      3.3         大写字母，小写字母都可以，只能出现2-3次[a-zA-Z]&#123;2,3&#125;
        //      我们可以把3.2和3.3看成一组，这一组可以出现1次或者两次
        String regex3 = &quot;\\w+@[\\w&amp;&amp;[^_]]&#123;2,6&#125;(\\.[a-zA-Z]&#123;2,3&#125;)&#123;1,2&#125;&quot;;
        System.out.println(&quot;3232323@qq.com&quot;.matches(regex3));
        System.out.println(&quot;zhangsan@itcast.cnn&quot;.matches(regex3));
        System.out.println(&quot;dlei0009@163.com&quot;.matches(regex3));
        System.out.println(&quot;dlei0009@pci.com.cn&quot;.matches(regex3));


        //24小时的正则表达式
        String regex4 = &quot;([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d&quot;;
        System.out.println(&quot;23:11:11&quot;.matches(regex4));

        String regex5 = &quot;([01]\\d 2[0-3])(:[0-5]\\d)&#123;2&#125;&quot;;
        System.out.println(&quot;23:11:11&quot;.matches(regex5));
    &#125;
&#125;
</code></pre>
<h2 id="1-7-正则表达式练习2"><a href="#1-7-正则表达式练习2" class="headerlink" title="1.7 正则表达式练习2"></a>1.7 正则表达式练习2</h2><p>需求<br>    请编写正则表达式验证用户名是否满足要求。要求:大小写字母，数字，下划线一共4-16位<br>    请编写正则表达式验证身份证号码是否满足要求。<br>    简单要求:<br>            18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x<br>    复杂要求:<br>            按照身份证号码的格式严格要求。</p>
<p>​	身份证号码:<br>​		41080119930228457x<br>​		510801197609022309<br>​		15040119810705387X<br>​		130133197204039024<br>​		430102197606046442</p>
<p>代码示例：</p>
<pre><code class="java">public class RegexDemo5 &#123;
    public static void main(String[] args) &#123;
        /*
            正则表达式练习:
            需求
            请编写正则表达式验证用户名是否满足要求。要求:大小写字母，数字，下划线一共4-16位
            请编写正则表达式验证身份证号码是否满足要求。
            简单要求:
                18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x
            复杂要求:
                按照身份证号码的格式严格要求。

            身份证号码:
            41080119930228457x
            510801197609022309
            15040119810705387X
            130133197204039024 I
            430102197606046442
        */

        //用户名要求:大小写字母，数字，下划线一共4-16位
        String regex1 = &quot;\\w&#123;4,16&#125;&quot;;
        System.out.println(&quot;zhangsan&quot;.matches(regex1));
        System.out.println(&quot;lisi&quot;.matches(regex1));
        System.out.println(&quot;wangwu&quot;.matches(regex1));
        System.out.println(&quot;$123&quot;.matches(regex1));


        //身份证号码的简单校验:
        //18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x
        String regex2 = &quot;[1-9]\\d&#123;16&#125;(\\d|x|x)&quot;;
        String regex3 = &quot;[1-9]\\d&#123;16&#125;[\\dXx]&quot;;
        String regex5 = &quot;[1-9]\\d&#123;16&#125;(\\d(?i)x)&quot;;

        System.out.println(&quot;41080119930228457x&quot;.matches(regex3));
        System.out.println(&quot;510801197609022309&quot;.matches(regex3));
        System.out.println(&quot;15040119810705387X&quot;.matches(regex3));
        System.out.println(&quot;130133197204039024&quot;.matches(regex3));
        System.out.println(&quot;430102197606046442&quot;.matches(regex3));


        //忽略大小写的书写方式
        //在匹配的时候忽略abc的大小写
        String regex4 = &quot;a((?i)b)c&quot;;
        System.out.println(&quot;------------------------------&quot;);
        System.out.println(&quot;abc&quot;.matches(regex4));//true
        System.out.println(&quot;ABC&quot;.matches(regex4));//false
        System.out.println(&quot;aBc&quot;.matches(regex4));//true


        //身份证号码的严格校验
        //编写正则的小心得:
        //第一步:按照正确的数据进行拆分
        //第二步:找每一部分的规律，并编写正则表达式
        //第三步:把每一部分的正则拼接在一起，就是最终的结果
        //书写的时候:从左到右去书写。

        //410801 1993 02 28 457x
        //前面6位:省份，市区，派出所等信息，第一位不能是0，后面5位是任意数字       [1-9]\\d&#123;5&#125;
        //年的前半段: 18 19 20                                                (18|19|20)
        //年的后半段: 任意数字出现两次                                           \\d&#123;2&#125;
        //月份: 01~ 09 10 11 12                                               (@[1-9]|1[0-2])
        //日期: 01~09 10~19 20~29 30 31                                       (0[1-9]|[12]\\d|3[01])
        //后面四位: 任意数字出现3次 最后一位可以是数字也可以是大写x或者小写x        \\d&#123;3&#125;[\\dXx]
        String regex6 = &quot;[1-9]\\d&#123;5&#125;(18|19|20)\\d&#123;2&#125;(@[1-9]|1[0-2])(@[1-9]|[12]\\d|3[01])\\d&#123;3&#125;[\\dxXx]&quot;;

        System.out.println(&quot;41080119930228457x&quot;.matches(regex6));
        System.out.println(&quot;510801197609022309&quot;.matches(regex6));
        System.out.println(&quot;15040119810705387X&quot;.matches(regex6));
        System.out.println(&quot;130133197204039024&quot;.matches(regex6));
        System.out.println(&quot;430102197606046442&quot;.matches(regex6));


    &#125;
&#125;
</code></pre>
<h2 id="1-8-本地数据爬取"><a href="#1-8-本地数据爬取" class="headerlink" title="1.8 本地数据爬取"></a>1.8 本地数据爬取</h2><p>Pattern：表示正则表达式<br>Matcher：文本匹配器，作用按照正则表达式的规则去读取字符串，从头开始读取。<br>             在大串中去找符合匹配规则的子串。</p>
<p>代码示例：</p>
<pre><code class="java">package com.itheima.a08regexdemo;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexDemo6 &#123;
    public static void main(String[] args) &#123;
        /* 有如下文本，请按照要求爬取数据。
                Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，
                因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台
                要求:找出里面所有的JavaXX
         */

        String str = &quot;Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，&quot; +
                &quot;因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台&quot;;


        //1.获取正则表达式的对象
        Pattern p = Pattern.compile(&quot;Java\\d&#123;0,2&#125;&quot;);
        //2.获取文本匹配器的对象
        //拿着m去读取str，找符合p规则的子串
        Matcher m = p.matcher(str);

        //3.利用循环获取
        while (m.find()) &#123;
            String s = m.group();
            System.out.println(s);
        &#125;


    &#125;

    private static void method1(String str) &#123;
        //Pattern:表示正则表达式
        //Matcher: 文本匹配器，作用按照正则表达式的规则去读取字符串，从头开始读取。
        //          在大串中去找符合匹配规则的子串。

        //获取正则表达式的对象
        Pattern p = Pattern.compile(&quot;Java\\d&#123;0,2&#125;&quot;);
        //获取文本匹配器的对象
        //m:文本匹配器的对象
        //str:大串
        //p:规则
        //m要在str中找符合p规则的小串
        Matcher m = p.matcher(str);

        //拿着文本匹配器从头开始读取，寻找是否有满足规则的子串
        //如果没有，方法返回false
        //如果有，返回true。在底层记录子串的起始索引和结束索引+1
        // 0,4
        boolean b = m.find();

        //方法底层会根据find方法记录的索引进行字符串的截取
        // substring(起始索引，结束索引);包头不包尾
        // (0,4)但是不包含4索引
        // 会把截取的小串进行返回。
        String s1 = m.group();
        System.out.println(s1);


        //第二次在调用find的时候，会继续读取后面的内容
        //读取到第二个满足要求的子串，方法会继续返回true
        //并把第二个子串的起始索引和结束索引+1，进行记录
        b = m.find();

        //第二次调用group方法的时候，会根据find方法记录的索引再次截取子串
        String s2 = m.group();
        System.out.println(s2);
    &#125;
&#125;
</code></pre>
<h2 id="1-9-网络数据爬取（了解）"><a href="#1-9-网络数据爬取（了解）" class="headerlink" title="1.9 网络数据爬取（了解）"></a>1.9 网络数据爬取（了解）</h2><p>需求：</p>
<p>​	把连接:<a target="_blank" rel="noopener" href="https://m.sengzan.com/jiaoyu/29104.html?ivk">https://m.sengzan.com/jiaoyu/29104.html?ivk</a> sa&#x3D;1025883i中所有的身份证号码都爬取出来。</p>
<p>代码示例：</p>
<pre><code class="java">public class RegexDemo7 &#123;
    public static void main(String[] args) throws IOException &#123;
        /* 扩展需求2:
            把连接:https://m.sengzan.com/jiaoyu/29104.html?ivk sa=1025883i
            中所有的身份证号码都爬取出来。
        */

        //创建一个URL对象
        URL url = new URL(&quot;https://m.sengzan.com/jiaoyu/29104.html?ivk sa=1025883i&quot;);
        //连接上这个网址
        //细节:保证网络是畅通
        URLConnection conn = url.openConnection();//创建一个对象去读取网络中的数据
        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        String line;
        //获取正则表达式的对象pattern
        String regex = &quot;[1-9]\\d&#123;17&#125;&quot;;
        Pattern pattern = Pattern.compile(regex);//在读取的时候每次读一整行
        while ((line = br.readLine()) != null) &#123;
            //拿着文本匹配器的对象matcher按照pattern的规则去读取当前的这一行信息
            Matcher matcher = pattern.matcher(line);
            while (matcher.find()) &#123;
                System.out.println(matcher.group());
            &#125;
        &#125;
        br.close();
    &#125;
&#125;
</code></pre>
<h2 id="1-10-爬取数据练习"><a href="#1-10-爬取数据练习" class="headerlink" title="1.10 爬取数据练习"></a>1.10 爬取数据练习</h2><p>需求：</p>
<p>​	把下面文本中的座机电话，邮箱，手机号，热线都爬取出来。</p>
<p>来黑马程序员学习Java，手机号:18512516758，18512508907或者联系邮箱:<a href="mailto:&#x62;&#111;&#x6e;&#x69;&#117;&#64;&#105;&#x74;&#99;&#x61;&#x73;&#116;&#x2e;&#x63;&#110;">&#x62;&#111;&#x6e;&#x69;&#117;&#64;&#105;&#x74;&#99;&#x61;&#x73;&#116;&#x2e;&#x63;&#110;</a>，座机电话:01036517895，010-98951256邮箱:<a href="mailto:&#x62;&#x6f;&#122;&#x61;&#x69;&#x40;&#x69;&#x74;&#99;&#x61;&#115;&#x74;&#46;&#x63;&#110;">&#x62;&#x6f;&#122;&#x61;&#x69;&#x40;&#x69;&#x74;&#99;&#x61;&#115;&#x74;&#46;&#x63;&#110;</a>，热线电话:400-618-9090 ，400-618-4000，4006184000，4006189090手机号的正则表达式:1[3-9]\d{9}</p>
<p>代码示例：</p>
<pre><code class="java">package com.itheima.a08regexdemo;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexDemo8 &#123;
    public static void main(String[] args) &#123;
        /*
            需求:把下面文本中的座机电话，邮箱，手机号，热线都爬取出来。
            来黑马程序员学习Java，
            手机号:18512516758，18512508907或者联系邮箱:boniu@itcast.cn，
            座机电话:01036517895，010-98951256邮箱:bozai@itcast.cn，
            热线电话:400-618-9090 ，400-618-4000，4006184000，4006189090

            手机号的正则表达式:1[3-9]\d&#123;9&#125;
            邮箱的正则表达式:\w+@[\w&amp;&amp;[^_]]&#123;2,6&#125;(\.[a-zA-Z]&#123;2,3&#125;)&#123;1,2&#125;座机电话的正则表达式:θ\d&#123;2,3&#125;-?[1-9]\d&#123;4,9&#125;
            热线电话的正则表达式:400-?[1-9]\\d&#123;2&#125;-?[1-9]\\d&#123;3&#125;

        */

        String s = &quot;来黑马程序员学习Java，&quot; +
                &quot;电话:18512516758，18512508907&quot; + &quot;或者联系邮箱:boniu@itcast.cn，&quot; +
                &quot;座机电话:01036517895，010-98951256&quot; + &quot;邮箱:bozai@itcast.cn，&quot; +
                &quot;热线电话:400-618-9090 ，400-618-4000，4006184000，4006189090&quot;;

        System.out.println(&quot;400-618-9090&quot;);

        String regex = &quot;(1[3-9]\\d&#123;9&#125;)|(\\w+@[\\w&amp;&amp;[^_]]&#123;2,6&#125;(\\.[a-zA-Z]&#123;2,3&#125;)&#123;1,2&#125;)&quot; +
                &quot;|(0\\d&#123;2,3&#125;-?[1-9]\\d&#123;4,9&#125;)&quot; +
                &quot;(400-?[1-9]\\d&#123;2&#125;-?[1-9]\\d&#123;3&#125;)&quot;;

        //1.获取正则表达式的对象
        Pattern p = Pattern.compile(regex);

        //2.获取文本匹配器的对象
        //利用m去读取s，会按照p的规则找里面的小串
        Matcher m = p.matcher(s);
        //3.利用循环获取每一个数据 while(m.find())&#123;
        String str = m.group();
        System.out.println(str);

    &#125;
&#125;
</code></pre>
<h2 id="1-11-按要求爬取"><a href="#1-11-按要求爬取" class="headerlink" title="1.11 按要求爬取"></a>1.11 按要求爬取</h2><p>需求：</p>
<p>​	有如下文本，按要求爬取数据。   </p>
<p>​	 Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台。</p>
<p>需求1：</p>
<p>​	爬取版本号为8，11.17的Java文本，但是只要Java，不显示版本号。</p>
<p>需求2：</p>
<p>​	爬取版本号为8，11，17的Java文本。正确爬取结果为：Java8 Java11 Java17 Java17</p>
<p>需求3：</p>
<p>​	爬取除了版本号为8，11，17的Java文本。<br>代码示例：</p>
<pre><code class="java">public class RegexDemo9 &#123;
    public static void main(String[] args) &#123;
        /*
            有如下文本，按要求爬取数据。
                Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，
                因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台


            需求1:爬取版本号为8，11.17的Java文本，但是只要Java，不显示版本号。
            需求2:爬取版本号为8，11，17的Java文本。正确爬取结果为:Java8 Java11 Java17 Java17
            需求3:爬取除了版本号为8，11.17的Java文本，
        */
        String s = &quot;Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，&quot; +
            &quot;因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台&quot;;

        //1.定义正则表达式
        //?理解为前面的数据Java
        //=表示在Java后面要跟随的数据
        //但是在获取的时候，只获取前半部分
        //需求1:
        String regex1 = &quot;((?i)Java)(?=8|11|17)&quot;;
        //需求2:
        String regex2 = &quot;((?i)Java)(8|11|17)&quot;;
        String regex3 = &quot;((?i)Java)(?:8|11|17)&quot;;
        //需求3:
        String regex4 = &quot;((?i)Java)(?!8|11|17)&quot;;

        Pattern p = Pattern.compile(regex4);
        Matcher m = p.matcher(s);
        while (m.find()) &#123;
            System.out.println(m.group());
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="1-12-贪婪爬取和非贪婪爬取"><a href="#1-12-贪婪爬取和非贪婪爬取" class="headerlink" title="1.12 贪婪爬取和非贪婪爬取"></a>1.12 贪婪爬取和非贪婪爬取</h2><pre><code class="java">只写+和表示贪婪匹配，如果在+和后面加问号表示非贪婪爬取
+? 非贪婪匹配
*? 非贪婪匹配
贪婪爬取:在爬取数据的时候尽可能的多获取数据
非贪婪爬取:在爬取数据的时候尽可能的少获取数据

举例：
如果获取数据：ab+
贪婪爬取获取结果:abbbbbbbbbbbb
非贪婪爬取获取结果:ab
</code></pre>
<p>代码示例：</p>
<pre><code class="java">public class RegexDemo10 &#123;
    public static void main(String[] args) &#123;
        /*
            只写+和*表示贪婪匹配

            +? 非贪婪匹配
            *? 非贪婪匹配

            贪婪爬取:在爬取数据的时候尽可能的多获取数据
            非贪婪爬取:在爬取数据的时候尽可能的少获取数据

            ab+:
            贪婪爬取:abbbbbbbbbbbb
            非贪婪爬取:ab
        */
        String s = &quot;Java自从95年问世以来，abbbbbbbbbbbbaaaaaaaaaaaaaaaaaa&quot; +
                &quot;经历了很多版木，目前企业中用的最多的是]ava8和]ava11，因为这两个是长期支持版木。&quot; +
                &quot;下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台&quot;;

        String regex = &quot;ab+&quot;;
        Pattern p = Pattern.compile(regex);
        Matcher m = p.matcher(s);

        while (m.find()) &#123;
            System.out.println(m.group());
        &#125;


    &#125;
&#125;
</code></pre>
<h2 id="1-13-String的split方法中使用正则表达式"><a href="#1-13-String的split方法中使用正则表达式" class="headerlink" title="1.13 String的split方法中使用正则表达式"></a>1.13 String的split方法中使用正则表达式</h2><ul>
<li><p>String类的split()方法原型：</p>
<pre><code class="java">public String[] split(String regex)
//参数regex表示正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为&quot;分隔符&quot;来切割字符串。
</code></pre>
</li>
<li><p>代码示例：</p>
</li>
</ul>
<pre><code class="java">/*
            有一段字符串:小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠
            要求1:把字符串中三个姓名之间的字母替换为vs
            要求2:把字符串中的三个姓名切割出来*/

String s = &quot;小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠&quot;;
//细节:
//方法在底层跟之前一样也会创建文本解析器的对象
//然后从头开始去读取字符串中的内容，只要有满足的，那么就切割。
String[] arr = s.split(&quot;[\\w&amp;&amp;[^_]]+&quot;);
for (int i = 0; i &lt; arr.length; i++) &#123;
    System.out.println(arr[i]);
&#125;
</code></pre>
<h2 id="1-14-String类的replaceAll方法中使用正则表达式"><a href="#1-14-String类的replaceAll方法中使用正则表达式" class="headerlink" title="1.14 String类的replaceAll方法中使用正则表达式"></a>1.14 String类的replaceAll方法中使用正则表达式</h2><ul>
<li>String类的replaceAll()方法原型：</li>
</ul>
<pre><code class="java">public String replaceAll(String regex,String newStr)
//参数regex表示一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。
</code></pre>
<ul>
<li>代码示例：</li>
</ul>
<pre><code class="java">/*
            有一段字符串:小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠
            要求1:把字符串中三个姓名之间的字母替换为vs
            要求2:把字符串中的三个姓名切割出来*/

String s = &quot;小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠&quot;;
//细节:
//方法在底层跟之前一样也会创建文本解析器的对象
//然后从头开始去读取字符串中的内容，只要有满足的，那么就用第一个参数去替换。
String result1 = s.replaceAll(&quot;[\\w&amp;&amp;[^_]]+&quot;, &quot;vs&quot;);
System.out.println(result1);
</code></pre>
<h2 id="1-15-正则表达式-分组括号"><a href="#1-15-正则表达式-分组括号" class="headerlink" title="1.15 正则表达式-分组括号( )"></a>1.15 正则表达式-分组括号( )</h2><p>细节：如何识别组号？</p>
<p>只看左括号，不看有括号，按照左括号的顺序，从左往右，依次为第一组，第二组，第三组等等</p>
<pre><code class="java">//需求1:判断一个字符串的开始字符和结束字符是否一致?只考虑一个字符
//举例: a123a b456b 17891 &amp;abc&amp; a123b(false)
// \\组号:表示把第X组的内容再出来用一次
String regex1 = &quot;(.).+\\1&quot;;
System.out.println(&quot;a123a&quot;.matches(regex1));
System.out.println(&quot;b456b&quot;.matches(regex1));
System.out.println(&quot;17891&quot;.matches(regex1));
System.out.println(&quot;&amp;abc&amp;&quot;.matches(regex1));
System.out.println(&quot;a123b&quot;.matches(regex1));
System.out.println(&quot;--------------------------&quot;);


//需求2:判断一个字符串的开始部分和结束部分是否一致?可以有多个字符
//举例: abc123abc b456b 123789123 &amp;!@abc&amp;!@ abc123abd(false)
String regex2 = &quot;(.+).+\\1&quot;;
System.out.println(&quot;abc123abc&quot;.matches(regex2));
System.out.println(&quot;b456b&quot;.matches(regex2));
System.out.println(&quot;123789123&quot;.matches(regex2));
System.out.println(&quot;&amp;!@abc&amp;!@&quot;.matches(regex2));
System.out.println(&quot;abc123abd&quot;.matches(regex2));
System.out.println(&quot;---------------------&quot;);

//需求3:判断一个字符串的开始部分和结束部分是否一致?开始部分内部每个字符也需要一致
//举例: aaa123aaa bbb456bbb 111789111 &amp;&amp;abc&amp;&amp;
//(.):把首字母看做一组
// \\2:把首字母拿出来再次使用
// *:作用于\\2,表示后面重复的内容出现日次或多次
String regex3 = &quot;((.)\\2*).+\\1&quot;;
System.out.println(&quot;aaa123aaa&quot;.matches(regex3));
System.out.println(&quot;bbb456bbb&quot;.matches(regex3));
System.out.println(&quot;111789111&quot;.matches(regex3));
System.out.println(&quot;&amp;&amp;abc&amp;&amp;&quot;.matches(regex3));
System.out.println(&quot;aaa123aab&quot;.matches(regex3));
</code></pre>
<h2 id="1-16-分组练习"><a href="#1-16-分组练习" class="headerlink" title="1.16 分组练习"></a>1.16 分组练习</h2><p>需求:</p>
<p>​    将字符串：我要学学编编编编程程程程程程。</p>
<p>​    替换为：我要学编程</p>
<pre><code class="java">String str = &quot;我要学学编编编编程程程程程程&quot;;

//需求:把重复的内容 替换为 单个的
//学学                学
//编编编编            编
//程程程程程程        程
//  (.)表示把重复内容的第一个字符看做一组
//  \\1表示第一字符再次出现
//  + 至少一次
//  $1 表示把正则表达式中第一组的内容，再拿出来用
String result = str.replaceAll(&quot;(.)\\1+&quot;, &quot;$1&quot;);
System.out.println(result);
</code></pre>
<h2 id="1-17-忽略大小写的写法"><a href="#1-17-忽略大小写的写法" class="headerlink" title="1.17 忽略大小写的写法"></a>1.17 忽略大小写的写法</h2><pre><code class="java">//(?i) ：表示忽略后面数据的大小写
//忽略abc的大小写
String regex = &quot;(?i)abc&quot;;
//a需要一模一样，忽略bc的大小写
String regex = &quot;a(?i)bc&quot;;
//ac需要一模一样，忽略b的大小写
String regex = &quot;a((?i)b)c&quot;;
</code></pre>
<h2 id="1-18-非捕获分组"><a href="#1-18-非捕获分组" class="headerlink" title="1.18 非捕获分组"></a>1.18 非捕获分组</h2><p>非捕获分组：分组之后不需要再用本组数据，仅仅是把数据括起来。</p>
<pre><code class="java">//身份证号码的简易正则表达式
//非捕获分组:仅仅是把数据括起来
//特点:不占用组号
//这里\\1报错原因:(?:)就是非捕获分组，此时是不占用组号的。


//(?:) (?=) (?!)都是非捕获分组//更多的使用第一个
//String regex1 =&quot;[1-9]\\d&#123;16&#125;(?:\\d|x|x)\\1&quot;;
String regex2 =&quot;[1-9]\\d&#123;16&#125;(\\d Xx)\\1&quot;;
//^([01]\d|2[0-3]):[0-5]\d:[@-5]\d$

System.out.println(&quot;41080119930228457x&quot;.matches(regex2));
</code></pre>
<h2 id="1-19-正则表达式练习"><a href="#1-19-正则表达式练习" class="headerlink" title="1.19 正则表达式练习"></a>1.19 正则表达式练习</h2><pre><code class="java">手机号码:1[3-9]\\d&#123;9&#125;
座机号码：0\\d&#123;2,3&#125;-?[1-9]\\d&#123;4,9&#125;
邮箱号码：\\w+@[\\w&amp;&amp;[^_]]&#123;2,6&#125;(\\.[a-zA-Z]&#123;2,3&#125;)&#123;1,2&#125;
24小时：([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d
       ([01]\\d|2[0-3])(:[0-5]\\d)&#123;2&#125;
用户名:	\\w&#123;4,16&#125;
身份证号码，简单校验：
        [1-9]\\d&#123;16&#125;(\\d|X|x)
        [1-9]\\d&#123;16&#125;[\\dXx]
        [1-9]\\d&#123;16&#125;(\\d(?i)X)
身份证号码，严格校验：
        [1-9]\\d&#123;5&#125;(18|19|20)\\d&#123;2&#125;(0[1-9]|1[0-2])(0[1-9|[12])\\d|3[01])\\d&#123;3&#125;[\\dXx]
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 陈小达的个人博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenjunda
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"hibiki"},"log":false});</script></body>
</html>
