
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>IO流(其他流) | 陈小达的个人博客</title>
    <meta name="author" content="chenjunda" />
    <meta name="description" content="学习笔记" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>陈小达的个人博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-主页 fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-关于我 fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categoriest">
            <i class="fa-solid fa-分类 fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-标签 fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;陈小达的个人博客</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-主页 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-关于我 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categoriest">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-分类 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-标签 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>IO流(其他流)</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/6/28
        </span>
        
        <span class="category">
            <a href="/categories/java/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                java
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/javaSE/" style="color: #00a596">
                    javaSE
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="1-缓冲流"><a href="#1-缓冲流" class="headerlink" title="1. 缓冲流"></a>1. 缓冲流</h1><p>昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。</p>
<span id="more"></span>

<h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<h2 id="1-2-字节缓冲流"><a href="#1-2-字节缓冲流" class="headerlink" title="1.2 字节缓冲流"></a>1.2 字节缓冲流</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<p>构造举例，代码如下：</p>
<pre><code class="java">// 创建字节缓冲输入流
BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;bis.txt&quot;));
// 创建字节缓冲输出流
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;));
</code></pre>
<h3 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h3><p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p>
<ol>
<li>基本流，代码如下：</li>
</ol>
<pre><code class="java">public class BufferedDemo &#123;
    public static void main(String[] args) throws FileNotFoundException &#123;
        // 记录开始时间
          long start = System.currentTimeMillis();
        // 创建流对象
        try (
            FileInputStream fis = new FileInputStream(&quot;jdk9.exe&quot;);
            FileOutputStream fos = new FileOutputStream(&quot;copy.exe&quot;)
        )&#123;
            // 读写数据
            int b;
            while ((b = fis.read()) != -1) &#123;
                fos.write(b);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        // 记录结束时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;普通流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);
    &#125;
&#125;

十几分钟过去了...
</code></pre>
<ol start="2">
<li>缓冲流，代码如下：</li>
</ol>
<pre><code class="java">public class BufferedDemo &#123;
    public static void main(String[] args) throws FileNotFoundException &#123;
        // 记录开始时间
          long start = System.currentTimeMillis();
        // 创建流对象
        try (
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;));
         BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;));
        )&#123;
        // 读写数据
            int b;
            while ((b = bis.read()) != -1) &#123;
                bos.write(b);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        // 记录结束时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;缓冲流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);
    &#125;
&#125;

缓冲流复制时间:8016 毫秒
</code></pre>
<p>如何更快呢？</p>
<p>使用数组的方式，代码如下：</p>
<pre><code class="java">public class BufferedDemo &#123;
    public static void main(String[] args) throws FileNotFoundException &#123;
          // 记录开始时间
        long start = System.currentTimeMillis();
        // 创建流对象
        try (
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;));
         BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;));
        )&#123;
              // 读写数据
            int len;
            byte[] bytes = new byte[8*1024];
            while ((len = bis.read(bytes)) != -1) &#123;
                bos.write(bytes, 0 , len);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        // 记录结束时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);
    &#125;
&#125;
缓冲流使用数组复制时间:666 毫秒
</code></pre>
<h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<p>构造举例，代码如下：</p>
<pre><code class="java">// 创建字符缓冲输入流
BufferedReader br = new BufferedReader(new FileReader(&quot;br.txt&quot;));
// 创建字符缓冲输出流
BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;));
</code></pre>
<h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li>
<li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。</li>
</ul>
<p><code>readLine</code>方法演示，代码如下：</p>
<pre><code class="java">public class BufferedReaderDemo &#123;
    public static void main(String[] args) throws IOException &#123;
           // 创建流对象
        BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;));
        // 定义字符串,保存读取的一行文字
        String line  = null;
          // 循环读取,读取到最后返回null
        while ((line = br.readLine())!=null) &#123;
            System.out.print(line);
            System.out.println(&quot;------&quot;);
        &#125;
        // 释放资源
        br.close();
    &#125;
&#125;
</code></pre>
<p><code>newLine</code>方法演示，代码如下：</p>
<pre><code class="java">public class BufferedWriterDemo throws IOException &#123;
  public static void main(String[] args) throws IOException  &#123;
        // 创建流对象
      BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;));
        // 写出数据
      bw.write(&quot;黑马&quot;);
        // 写出换行
      bw.newLine();
      bw.write(&quot;程序&quot;);
      bw.newLine();
      bw.write(&quot;员&quot;);
      bw.newLine();
      // 释放资源
      bw.close();
  &#125;
&#125;
输出效果:
黑马
程序
员
</code></pre>
<h2 id="1-4-练习-文本排序"><a href="#1-4-练习-文本排序" class="headerlink" title="1.4 练习:文本排序"></a>1.4 练习:文本排序</h2><p>请将文本信息恢复顺序。</p>
<pre><code>3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。
8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。
4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。
2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。
1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。
9.今当远离，临表涕零，不知所言。
6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。
7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。
5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。
</code></pre>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>逐行读取文本信息。</li>
<li>把读取到的文本存储到集合中</li>
<li>对集合中的文本进行排序</li>
<li>遍历集合，按顺序，写出文本信息。</li>
</ol>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><pre><code class="java">public class Demo05Test &#123;
    public static void main(String[] args) throws IOException &#123;
        //1.创建ArrayList集合,泛型使用String
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        //2.创建BufferedReader对象,构造方法中传递FileReader对象
        BufferedReader br = new BufferedReader(new FileReader(&quot;10_IO\\in.txt&quot;));
        //3.创建BufferedWriter对象,构造方法中传递FileWriter对象
        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;10_IO\\out.txt&quot;));
        //4.使用BufferedReader对象中的方法readLine,以行的方式读取文本
        String line;
        while((line = br.readLine())!=null)&#123;
            //5.把读取到的文本存储到ArrayList集合中
            list.add(line);
        &#125;
        //6.使用Collections集合工具类中的方法sort,对集合中的元素按照自定义规则排序
        Collections.sort(list, new Comparator&lt;String&gt;() &#123;
            /*
                o1-o2:升序
                o2-o1:降序
             */
            @Override
            public int compare(String o1, String o2) &#123;
                //依次比较集合中两个元素的首字母,升序排序
                return o1.charAt(0)-o2.charAt(0);
            &#125;
        &#125;);
        //7.遍历ArrayList集合,获取每一个元素
        for (String s : list) &#123;
            //8.使用BufferedWriter对象中的方法wirte,把遍历得到的元素写入到文本中(内存缓冲区中)
            bw.write(s);
            //9.写换行
            bw.newLine();
        &#125;
        //10.释放资源
        bw.close();
        br.close();
    &#125;
&#125;
</code></pre>
<h1 id="2-转换流"><a href="#2-转换流" class="headerlink" title="2. 转换流"></a>2. 转换流</h1><h2 id="2-1-字符编码和字符集"><a href="#2-1-字符编码和字符集" class="headerlink" title="2.1 字符编码和字符集"></a>2.1 字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p>
<p>编码:字符(能看懂的)–字节(看不懂的)</p>
<p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p>
<ul>
<li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p>编码表:生活中文字和计算机中二进制的对应规则</p>
</li>
</ul>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul>
<li>**字符集 <code>Charset</code>**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
</ul>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。<img src="D:\HuaweiMoveData\Users\86147\Desktop\黑马java资料\新建文件夹\img\1_charset.jpg"></p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<ul>
<li><strong>ASCII字符集</strong> ：<ul>
<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li>
<li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li>
</ul>
</li>
<li><strong>ISO-8859-1字符集</strong>：<ul>
<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li>
</ul>
</li>
<li><strong>GBxxx字符集</strong>：<ul>
<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul>
</li>
<li><strong>Unicode字符集</strong> ：<ul>
<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li>
<li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol>
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。 </li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-编码引出的问题"><a href="#2-2-编码引出的问题" class="headerlink" title="2.2 编码引出的问题"></a>2.2 编码引出的问题</h2><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p>
<pre><code class="java">public class ReaderDemo &#123;
    public static void main(String[] args) throws IOException &#123;
        FileReader fileReader = new FileReader(&quot;E:\\File_GBK.txt&quot;);
        int read;
        while ((read = fileReader.read()) != -1) &#123;
            System.out.print((char)read);
        &#125;
        fileReader.close();
    &#125;
&#125;
输出结果：
���
</code></pre>
<p>那么如何读取GBK编码的文件呢？ </p>
<h2 id="2-3-InputStreamReader类"><a href="#2-3-InputStreamReader类" class="headerlink" title="2.3 InputStreamReader类"></a>2.3 InputStreamReader类</h2><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>构造举例，代码如下： </p>
<pre><code class="java">InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;));
InputStreamReader isr2 = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;) , &quot;GBK&quot;);
</code></pre>
<h3 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h3><pre><code class="java">public class ReaderDemo2 &#123;
    public static void main(String[] args) throws IOException &#123;
          // 定义文件路径,文件为gbk编码
        String FileName = &quot;E:\\file_gbk.txt&quot;;
          // 创建流对象,默认UTF8编码
        InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));
          // 创建流对象,指定GBK编码
        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , &quot;GBK&quot;);
        // 定义变量,保存字符
        int read;
          // 使用默认编码字符流读取,乱码
        while ((read = isr.read()) != -1) &#123;
            System.out.print((char)read); // ��Һ�
        &#125;
        isr.close();
      
          // 使用指定编码字符流读取,正常解析
        while ((read = isr2.read()) != -1) &#123;
            System.out.print((char)read);// 大家好
        &#125;
        isr2.close();
    &#125;
&#125;
</code></pre>
<h2 id="2-4-OutputStreamWriter类"><a href="#2-4-OutputStreamWriter类" class="headerlink" title="2.4 OutputStreamWriter类"></a>2.4 OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>构造举例，代码如下： </p>
<pre><code class="java">OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;));
OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;) , &quot;GBK&quot;);
</code></pre>
<h3 id="指定编码写出"><a href="#指定编码写出" class="headerlink" title="指定编码写出"></a>指定编码写出</h3><pre><code class="java">public class OutputDemo &#123;
    public static void main(String[] args) throws IOException &#123;
          // 定义文件路径
        String FileName = &quot;E:\\out.txt&quot;;
          // 创建流对象,默认UTF8编码
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));
        // 写出数据
          osw.write(&quot;你好&quot;); // 保存为6个字节
        osw.close();
          
        // 定义文件路径
        String FileName2 = &quot;E:\\out2.txt&quot;;
         // 创建流对象,指定GBK编码
        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;);
        // 写出数据
          osw2.write(&quot;你好&quot;);// 保存为4个字节
        osw2.close();
    &#125;
&#125;
</code></pre>
<h3 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h3><p><strong>转换流是字节与字符间的桥梁！</strong><img src="D:\HuaweiMoveData\Users\86147\Desktop\黑马java资料\新建文件夹\img\2_zhuanhuan.jpg"></p>
<h2 id="2-5-练习：转换文件编码"><a href="#2-5-练习：转换文件编码" class="headerlink" title="2.5 练习：转换文件编码"></a>2.5 练习：转换文件编码</h2><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p>
<h3 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>指定GBK编码的转换流，读取文本文件。</li>
<li>使用UTF-8编码的转换流，写出文本文件。</li>
</ol>
<h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><pre><code class="java">public class TransDemo &#123;
   public static void main(String[] args) &#123;      
        // 1.定义文件路径
         String srcFile = &quot;file_gbk.txt&quot;;
        String destFile = &quot;file_utf8.txt&quot;;
        // 2.创建流对象
        // 2.1 转换输入流,指定GBK编码
        InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , &quot;GBK&quot;);
        // 2.2 转换输出流,默认utf8编码
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile));
        // 3.读写数据
        // 3.1 定义数组
        char[] cbuf = new char[1024];
        // 3.2 定义长度
        int len;
        // 3.3 循环读取
        while ((len = isr.read(cbuf))!=-1) &#123;
            // 循环写出
              osw.write(cbuf,0,len);
        &#125;
        // 4.释放资源
        osw.close();
        isr.close();
      &#125;
&#125;
</code></pre>
<h1 id="3-序列化"><a href="#3-序列化" class="headerlink" title="3. 序列化"></a>3. 序列化</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： <img src="D:\HuaweiMoveData\Users\86147\Desktop\黑马java资料\新建文件夹\img\3_xuliehua.jpg"></p>
<h2 id="3-2-ObjectOutputStream类"><a href="#3-2-ObjectOutputStream类" class="headerlink" title="3.2 ObjectOutputStream类"></a>3.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</li>
</ul>
<p>构造举例，代码如下：  </p>
<pre><code class="java">FileOutputStream fileOut = new FileOutputStream(&quot;employee.txt&quot;);
ObjectOutputStream out = new ObjectOutputStream(fileOut);
</code></pre>
<h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol>
<li>一个对象要想序列化，必须满足两个条件:</li>
</ol>
<ul>
<li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
</ul>
<pre><code class="java">public class Employee implements java.io.Serializable &#123;
    public String name;
    public String address;
    public transient int age; // transient瞬态修饰成员,不会被序列化
    public void addressCheck() &#123;
          System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);
    &#125;
&#125;
</code></pre>
<p>2.写出对象方法</p>
<ul>
<li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li>
</ul>
<pre><code class="java">public class SerializeDemo&#123;
       public static void main(String [] args)   &#123;
        Employee e = new Employee();
        e.name = &quot;zhangsan&quot;;
        e.address = &quot;beiqinglu&quot;;
        e.age = 20; 
        try &#123;
              // 创建序列化流对象
          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;));
            // 写出对象
            out.writeObject(e);
            // 释放资源
            out.close();
            fileOut.close();
            System.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。
        &#125; catch(IOException i)   &#123;
            i.printStackTrace();
        &#125;
       &#125;
&#125;
输出结果：
Serialized data is saved
</code></pre>
<h2 id="3-3-ObjectInputStream类"><a href="#3-3-ObjectInputStream类" class="headerlink" title="3.3 ObjectInputStream类"></a>3.3 ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p>
<h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li>
</ul>
<h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p>
<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
<pre><code class="java">public class DeserializeDemo &#123;
   public static void main(String [] args)   &#123;
        Employee e = null;
        try &#123;		
             // 创建反序列化流
             FileInputStream fileIn = new FileInputStream(&quot;employee.txt&quot;);
             ObjectInputStream in = new ObjectInputStream(fileIn);
             // 读取一个对象
             e = (Employee) in.readObject();
             // 释放资源
             in.close();
             fileIn.close();
        &#125;catch(IOException i) &#123;
             // 捕获其他异常
             i.printStackTrace();
             return;
        &#125;catch(ClassNotFoundException c)  &#123;
            // 捕获类找不到异常
             System.out.println(&quot;Employee class not found&quot;);
             c.printStackTrace();
             return;
        &#125;
        // 无异常,直接打印输出
        System.out.println(&quot;Name: &quot; + e.name);	// zhangsan
        System.out.println(&quot;Address: &quot; + e.address); // beiqinglu
        System.out.println(&quot;age: &quot; + e.age); // 0
    &#125;
&#125;
</code></pre>
<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p>
<h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h3><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>该类包含未知数据类型 </li>
<li>该类没有可访问的无参数构造方法</li>
</ul>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<pre><code class="java">public class Employee implements java.io.Serializable &#123;
     // 加入序列版本号
     private static final long serialVersionUID = 1L;
     public String name;
     public String address;
     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.
     public int eid; 

     public void addressCheck() &#123;
         System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);
     &#125;
&#125;
</code></pre>
<h2 id="3-4-练习：序列化集合"><a href="#3-4-练习：序列化集合" class="headerlink" title="3.4 练习：序列化集合"></a>3.4 练习：序列化集合</h2><ol>
<li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li>
<li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<h3 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>把若干学生对象 ，保存到集合中。</li>
<li>把集合序列化。</li>
<li>反序列化读取时，只需要读取一次，转换为集合类型。</li>
<li>遍历集合，可以打印所有的学生信息</li>
</ol>
<h3 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h3><pre><code class="java">public class SerTest &#123;
    public static void main(String[] args) throws Exception &#123;
        // 创建 学生对象
        Student student = new Student(&quot;老王&quot;, &quot;laow&quot;);
        Student student2 = new Student(&quot;老张&quot;, &quot;laoz&quot;);
        Student student3 = new Student(&quot;老李&quot;, &quot;laol&quot;);

        ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;();
        arrayList.add(student);
        arrayList.add(student2);
        arrayList.add(student3);
        // 序列化操作
        // serializ(arrayList);
        
        // 反序列化  
        ObjectInputStream ois  = new ObjectInputStream(new FileInputStream(&quot;list.txt&quot;));
        // 读取对象,强转为ArrayList类型
        ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();
        
          for (int i = 0; i &lt; list.size(); i++ )&#123;
              Student s = list.get(i);
            System.out.println(s.getName()+&quot;--&quot;+ s.getPwd());
          &#125;
    &#125;

    private static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception &#123;
        // 创建 序列化流 
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;list.txt&quot;));
        // 写出对象
        oos.writeObject(arrayList);
        // 释放资源
        oos.close();
    &#125;
&#125;
</code></pre>
<h1 id="4-打印流"><a href="#4-打印流" class="headerlink" title="4. 打印流"></a>4. 打印流</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<h2 id="4-2-PrintStream类"><a href="#4-2-PrintStream类" class="headerlink" title="4.2 PrintStream类"></a>4.2 PrintStream类</h2><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li>
</ul>
<p>构造举例，代码如下：  </p>
<pre><code class="java">PrintStream ps = new PrintStream(&quot;ps.txt&quot;)；
</code></pre>
<h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p>
<pre><code class="java">public class PrintDemo &#123;
    public static void main(String[] args) throws IOException &#123;
        // 调用系统的打印流,控制台直接输出97
        System.out.println(97);
      
        // 创建打印流,指定文件的名称
        PrintStream ps = new PrintStream(&quot;ps.txt&quot;);
          
          // 设置系统的打印流流向,输出到ps.txt
        System.setOut(ps);
          // 调用系统的打印流,ps.txt中输出97
        System.out.println(97);
    &#125;
&#125;
</code></pre>
<h1 id="5-压缩流和解压缩流"><a href="#5-压缩流和解压缩流" class="headerlink" title="5. 压缩流和解压缩流"></a>5. 压缩流和解压缩流</h1><p>压缩流：</p>
<p>​	负责压缩文件或者文件夹</p>
<p>解压缩流：</p>
<p>​	负责把压缩包中的文件和文件夹解压出来</p>
<pre><code class="java">/*
*   解压缩流
*
* */
public class ZipStreamDemo1 &#123;
    public static void main(String[] args) throws IOException &#123;

        //1.创建一个File表示要解压的压缩包
        File src = new File(&quot;D:\\aaa.zip&quot;);
        //2.创建一个File表示解压的目的地
        File dest = new File(&quot;D:\\&quot;);

        //调用方法
        unzip(src,dest);

    &#125;

    //定义一个方法用来解压
    public static void unzip(File src,File dest) throws IOException &#123;
        //解压的本质：把压缩包里面的每一个文件或者文件夹读取出来，按照层级拷贝到目的地当中
        //创建一个解压缩流用来读取压缩包中的数据
        ZipInputStream zip = new ZipInputStream(new FileInputStream(src));
        //要先获取到压缩包里面的每一个zipentry对象
        //表示当前在压缩包中获取到的文件或者文件夹
        ZipEntry entry;
        while((entry = zip.getNextEntry()) != null)&#123;
            System.out.println(entry);
            if(entry.isDirectory())&#123;
                //文件夹：需要在目的地dest处创建一个同样的文件夹
                File file = new File(dest,entry.toString());
                file.mkdirs();
            &#125;else&#123;
                //文件：需要读取到压缩包中的文件，并把他存放到目的地dest文件夹中（按照层级目录进行存放）
                FileOutputStream fos = new FileOutputStream(new File(dest,entry.toString()));
                int b;
                while((b = zip.read()) != -1)&#123;
                    //写到目的地
                    fos.write(b);
                &#125;
                fos.close();
                //表示在压缩包中的一个文件处理完毕了。
                zip.closeEntry();
            &#125;
        &#125;
        zip.close();
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class ZipStreamDemo2 &#123;
    public static void main(String[] args) throws IOException &#123;
        /*
         *   压缩流
         *      需求：
         *          把D:\\a.txt打包成一个压缩包
         * */
        //1.创建File对象表示要压缩的文件
        File src = new File(&quot;D:\\a.txt&quot;);
        //2.创建File对象表示压缩包的位置
        File dest = new File(&quot;D:\\&quot;);
        //3.调用方法用来压缩
        toZip(src,dest);
    &#125;

    /*
    *   作用：压缩
    *   参数一：表示要压缩的文件
    *   参数二：表示压缩包的位置
    * */
    public static void toZip(File src,File dest) throws IOException &#123;
        //1.创建压缩流关联压缩包
        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(dest,&quot;a.zip&quot;)));
        //2.创建ZipEntry对象，表示压缩包里面的每一个文件和文件夹
        //参数：压缩包里面的路径
        ZipEntry entry = new ZipEntry(&quot;aaa\\bbb\\a.txt&quot;);
        //3.把ZipEntry对象放到压缩包当中
        zos.putNextEntry(entry);
        //4.把src文件中的数据写到压缩包当中
        FileInputStream fis = new FileInputStream(src);
        int b;
        while((b = fis.read()) != -1)&#123;
            zos.write(b);
        &#125;
        zos.closeEntry();
        zos.close();
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class ZipStreamDemo3 &#123;
    public static void main(String[] args) throws IOException &#123;
        /*
         *   压缩流
         *      需求：
         *          把D:\\aaa文件夹压缩成一个压缩包
         * */
        //1.创建File对象表示要压缩的文件夹
        File src = new File(&quot;D:\\aaa&quot;);
        //2.创建File对象表示压缩包放在哪里（压缩包的父级路径）
        File destParent = src.getParentFile();//D:\\
        //3.创建File对象表示压缩包的路径
        File dest = new File(destParent,src.getName() + &quot;.zip&quot;);
        //4.创建压缩流关联压缩包
        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(dest));
        //5.获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中
        toZip(src,zos,src.getName());//aaa
        //6.释放资源
        zos.close();
    &#125;

    /*
    *   作用：获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中
    *   参数一：数据源
    *   参数二：压缩流
    *   参数三：压缩包内部的路径
    * */
    public static void toZip(File src,ZipOutputStream zos,String name) throws IOException &#123;
        //1.进入src文件夹
        File[] files = src.listFiles();
        //2.遍历数组
        for (File file : files) &#123;
            if(file.isFile())&#123;
                //3.判断-文件，变成ZipEntry对象，放入到压缩包当中
                ZipEntry entry = new ZipEntry(name + &quot;\\&quot; + file.getName());//aaa\\no1\\a.txt
                zos.putNextEntry(entry);
                //读取文件中的数据，写到压缩包
                FileInputStream fis = new FileInputStream(file);
                int b;
                while((b = fis.read()) != -1)&#123;
                    zos.write(b);
                &#125;
                fis.close();
                zos.closeEntry();
            &#125;else&#123;
                //4.判断-文件夹，递归
                toZip(file,zos,name + &quot;\\&quot; + file.getName());
                //     no1            aaa   \\   no1
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="6-工具包（Commons-io）"><a href="#6-工具包（Commons-io）" class="headerlink" title="6. 工具包（Commons-io）"></a>6. 工具包（Commons-io）</h1><p>介绍：</p>
<p>​	Commons是apache开源基金组织提供的工具包，里面有很多帮助我们提高开发效率的API</p>
<p>比如：</p>
<p>​	StringUtils   字符串工具类</p>
<p>​	NumberUtils   数字工具类 </p>
<p>​	ArrayUtils   数组工具类  </p>
<p>​	RandomUtils   随机数工具类</p>
<p>​	DateUtils   日期工具类 </p>
<p>​	StopWatch   秒表工具类 </p>
<p>​	ClassUtils   反射工具类  </p>
<p>​	SystemUtils   系统工具类  </p>
<p>​	MapUtils   集合工具类</p>
<p>​	Beanutils   bean工具类</p>
<p>​	Commons-io io的工具类</p>
<p>​	等等…..</p>
<p>其中：Commons-io是apache开源基金组织提供的一组有关IO操作的开源工具包。</p>
<p>作用：提高IO流的开发效率。</p>
<p>使用方式：</p>
<p>1，新建lib文件夹</p>
<p>2，把第三方jar包粘贴到文件夹中</p>
<p>3，右键点击add as a library</p>
<p>代码示例：</p>
<pre><code class="java">public class CommonsIODemo1 &#123;
    public static void main(String[] args) throws IOException &#123;
        /*
          FileUtils类
                static void copyFile(File srcFile, File destFile)                   复制文件
                static void copyDirectory(File srcDir, File destDir)                复制文件夹
                static void copyDirectoryToDirectory(File srcDir, File destDir)     复制文件夹
                static void deleteDirectory(File directory)                         删除文件夹
                static void cleanDirectory(File directory)                          清空文件夹
                static String readFileToString(File file, Charset encoding)         读取文件中的数据变成成字符串
                static void write(File file, CharSequence data, String encoding)    写出数据

            IOUtils类
                public static int copy(InputStream input, OutputStream output)      复制文件
                public static int copyLarge(Reader input, Writer output)            复制大文件
                public static String readLines(Reader input)                        读取数据
                public static void write(String data, OutputStream output)          写出数据
         */


        /* File src = new File(&quot;myio\\a.txt&quot;);
        File dest = new File(&quot;myio\\copy.txt&quot;);
        FileUtils.copyFile(src,dest);*/


        /*File src = new File(&quot;D:\\aaa&quot;);
        File dest = new File(&quot;D:\\bbb&quot;);
        FileUtils.copyDirectoryToDirectory(src,dest);*/

        /*File src = new File(&quot;D:\\bbb&quot;);
        FileUtils.cleanDirectory(src);*/



    &#125;
&#125;
</code></pre>
<h1 id="7-工具包（hutool）"><a href="#7-工具包（hutool）" class="headerlink" title="7. 工具包（hutool）"></a>7. 工具包（hutool）</h1><p>介绍：</p>
<p>​	Commons是国人开发的开源工具包，里面有很多帮助我们提高开发效率的API</p>
<p>比如：</p>
<p>​	DateUtil  日期时间工具类 </p>
<p>​	TimeInterval  计时器工具类 </p>
<p>​	StrUtil  字符串工具类</p>
<p>​	HexUtil   16进制工具类</p>
<p>​	HashUtil   Hash算法类</p>
<p>​	ObjectUtil  对象工具类</p>
<p>​	ReflectUtil   反射工具类</p>
<p>​	TypeUtil  泛型类型工具类</p>
<p>​	PageUtil  分页工具类</p>
<p>​	NumberUtil  数字工具类</p>
<p>使用方式：</p>
<p>1，新建lib文件夹</p>
<p>2，把第三方jar包粘贴到文件夹中</p>
<p>3，右键点击add as a library</p>
<p>代码示例：</p>
<pre><code class="java">public class Test1 &#123;
    public static void main(String[] args) &#123;
    /*
        FileUtil类:
                file：根据参数创建一个file对象
                touch：根据参数创建文件

                writeLines：把集合中的数据写出到文件中，覆盖模式。
                appendLines：把集合中的数据写出到文件中，续写模式。
                readLines：指定字符编码，把文件中的数据，读到集合中。
                readUtf8Lines：按照UTF-8的形式，把文件中的数据，读到集合中

                copy：拷贝文件或者文件夹
    */


       /* File file1 = FileUtil.file(&quot;D:\\&quot;, &quot;aaa&quot;, &quot;bbb&quot;, &quot;a.txt&quot;);
        System.out.println(file1);//D:\aaa\bbb\a.txt

        File touch = FileUtil.touch(file1);
        System.out.println(touch);


        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;aaa&quot;);
        list.add(&quot;aaa&quot;);
        list.add(&quot;aaa&quot;);

        File file2 = FileUtil.writeLines(list, &quot;D:\\a.txt&quot;, &quot;UTF-8&quot;);
        System.out.println(file2);*/

      /*  ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;aaa&quot;);
        list.add(&quot;aaa&quot;);
        list.add(&quot;aaa&quot;);
        File file3 = FileUtil.appendLines(list, &quot;D:\\a.txt&quot;, &quot;UTF-8&quot;);
        System.out.println(file3);*/
        List&lt;String&gt; list = FileUtil.readLines(&quot;D:\\a.txt&quot;, &quot;UTF-8&quot;);
        System.out.println(list);
    &#125;
&#125;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 陈小达的个人博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;chenjunda
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
